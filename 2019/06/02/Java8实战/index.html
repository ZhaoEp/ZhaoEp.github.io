<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="《Java8实战》"><meta name="keywords" content="java,读书笔记"><meta name="author" content="ZEP"><meta name="copyright" content="ZEP"><title>《Java8实战》 | Data Castle</title><link rel="shortcut icon" href="/img/icon/site.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#流处理"><span class="toc-number">1.</span> <span class="toc-text">流处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#特点"><span class="toc-number">1.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用"><span class="toc-number">1.2.</span> <span class="toc-text">使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本"><span class="toc-number">1.2.1.</span> <span class="toc-text">基本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#算子"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">算子</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#transform"><span class="toc-number">1.2.1.1.1.</span> <span class="toc-text">transform</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#action"><span class="toc-number">1.2.1.1.2.</span> <span class="toc-text">action</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建流"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">创建流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#值创建流"><span class="toc-number">1.2.1.2.1.</span> <span class="toc-text">值创建流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数组创建流"><span class="toc-number">1.2.1.2.2.</span> <span class="toc-text">数组创建流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#文件创建流"><span class="toc-number">1.2.1.2.3.</span> <span class="toc-text">文件创建流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#函数创建流：无限流"><span class="toc-number">1.2.1.2.4.</span> <span class="toc-text">函数创建流：无限流</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数值流"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">数值流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#创建数值流"><span class="toc-number">1.2.1.3.1.</span> <span class="toc-text">创建数值流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#对象流转换成数值流"><span class="toc-number">1.2.1.3.2.</span> <span class="toc-text">对象流转换成数值流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数值流转换为对象流"><span class="toc-number">1.2.1.3.3.</span> <span class="toc-text">数值流转换为对象流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#collect使用详解"><span class="toc-number">1.2.2.</span> <span class="toc-text">collect使用详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并行流"><span class="toc-number">1.2.3.</span> <span class="toc-text">并行流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原理"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ForkJoinPool"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">ForkJoinPool</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spliterator"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">Spliterator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高效使用"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">高效使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优势"><span class="toc-number">1.3.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#collection-和-stream"><span class="toc-number">1.4.</span> <span class="toc-text">collection 和 stream</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lambda-———-匿名函数"><span class="toc-number">2.</span> <span class="toc-text">Lambda ——— 匿名函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#接口的默认方法"><span class="toc-number">3.</span> <span class="toc-text">接口的默认方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Optional"><span class="toc-number">4.</span> <span class="toc-text">Optional</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建-1"><span class="toc-number">4.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用方法"><span class="toc-number">4.2.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CompletableFuture：组合异步编程"><span class="toc-number">5.</span> <span class="toc-text">CompletableFuture：组合异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Future"><span class="toc-number">5.1.</span> <span class="toc-text">Future</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-1"><span class="toc-number">5.1.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局限"><span class="toc-number">5.1.2.</span> <span class="toc-text">局限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CompletableFuture"><span class="toc-number">5.2.</span> <span class="toc-text">CompletableFuture</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#新的时间和日期"><span class="toc-number">6.</span> <span class="toc-text">新的时间和日期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LocalDate"><span class="toc-number">6.1.</span> <span class="toc-text">LocalDate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LocalTime"><span class="toc-number">6.2.</span> <span class="toc-text">LocalTime</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LocalDateTime"><span class="toc-number">6.3.</span> <span class="toc-text">LocalDateTime</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Instant"><span class="toc-number">6.4.</span> <span class="toc-text">Instant</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Duration-和-Period"><span class="toc-number">6.5.</span> <span class="toc-text">Duration 和 Period</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Period"><span class="toc-number">6.6.</span> <span class="toc-text">Period</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解析"><span class="toc-number">6.7.</span> <span class="toc-text">解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#时区"><span class="toc-number">6.8.</span> <span class="toc-text">时区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他的日历系统"><span class="toc-number">6.9.</span> <span class="toc-text">其他的日历系统</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/icon/t3.png"></div><div class="author-info__name text-center">ZEP</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/frog1024">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">4</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">6</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/top_background/jobs.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Data Castle</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/abouts">About</a></span></div><div id="post-info"><div id="post-title">《Java8实战》</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-02</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h1><p>在Java8中，可以使用流来对数据进行处理，形如<code>Stream&lt;T&gt;</code></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>以声明性方式处理数据集合</li>
<li>可以透明地并行处理</li>
<li>流只能遍历一次</li>
</ol>
<a id="more"></a>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><h4 id="算子"><a href="#算子" class="headerlink" title="算子"></a>算子</h4><h5 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h5><p>筛选和切片</p>
<ol>
<li>filter</li>
<li>distinct：根据hashCode和equals实现去重</li>
<li>limit</li>
<li>skip：扔掉前n给元素，如果流中的数据不够，则全部扔掉并返回要给空流</li>
</ol>
<p>映射</p>
<ol>
<li>map</li>
<li>flatMap</li>
</ol>
<p>查找与匹配</p>
<ol>
<li>anyMatch</li>
<li>allMatch</li>
<li>noneMatch</li>
<li>findAny</li>
</ol>
<h5 id="action"><a href="#action" class="headerlink" title="action"></a>action</h5><ol>
<li>collect</li>
<li>foreach</li>
<li>reduce</li>
<li>count</li>
<li>max</li>
<li>min</li>
</ol>
<h4 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h4><h5 id="值创建流"><a href="#值创建流" class="headerlink" title="值创建流"></a>值创建流</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>)</span><br></pre></td></tr></table></figure>

<h5 id="数组创建流"><a href="#数组创建流" class="headerlink" title="数组创建流"></a>数组创建流</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.stream(numbers);</span><br></pre></td></tr></table></figure>

<h5 id="文件创建流"><a href="#文件创建流" class="headerlink" title="文件创建流"></a>文件创建流</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.lines(Paths.get(<span class="string">"a.txt"</span>), Charset.defaultCharset())</span><br></pre></td></tr></table></figure>

<h5 id="函数创建流：无限流"><a href="#函数创建流：无限流" class="headerlink" title="函数创建流：无限流"></a>函数创建流：无限流</h5><p><code>iterate</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 偶数无限流</span></span><br><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><code>generate</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 随机数无限流 </span></span><br><span class="line">Stream.generate(Math::random)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>无限流在测试的时候，记得使用<code>limit</code>来获取固定的条数，否则不会停止，一直运行</p>
</blockquote>
<h4 id="数值流"><a href="#数值流" class="headerlink" title="数值流"></a>数值流</h4><p>Java为我们提供了3种类型的数值流</p>
<ol>
<li><code>IntStream</code></li>
<li><code>DoubleStream</code></li>
<li><code>LongStream</code></li>
</ol>
<blockquote>
<p> 在使用流进行数据处理的时候，一定要注意装箱的开销</p>
</blockquote>
<h5 id="创建数值流"><a href="#创建数值流" class="headerlink" title="创建数值流"></a>创建数值流</h5><p><code>IntStream.rangeClosed(1, 100)</code></p>
<h5 id="对象流转换成数值流"><a href="#对象流转换成数值流" class="headerlink" title="对象流转换成数值流"></a>对象流转换成数值流</h5><ol>
<li><code>mapToInt</code></li>
<li><code>mapToDouble</code></li>
<li><code>mapToLong</code></li>
</ol>
<h5 id="数值流转换为对象流"><a href="#数值流转换为对象流" class="headerlink" title="数值流转换为对象流"></a>数值流转换为对象流</h5><p><code>intStream.boxed()</code></p>
<h3 id="collect使用详解"><a href="#collect使用详解" class="headerlink" title="collect使用详解"></a>collect使用详解</h3><ol>
<li><p>counting：<code>collect(Collectors.counting())</code></p>
</li>
<li><p>maxBy：<code>collect(Collectors.maxBy(Comparator.comparingInt(Dish::getCalories)))</code></p>
</li>
<li><p>minBy：<code>collect(Collectors.minBy(Comparator.comparingInt(Dish::getCalories)))</code></p>
</li>
<li><p>summingInt：<code>collect(Collectors.summingInt(Dish::getCalories))</code></p>
</li>
<li><p>averagingInt：<code>collect(Collectors.averagingInt(Dish::getCalories))</code></p>
</li>
<li><p>summarizingInt：<code>collect(Collectors.summarizingInt(Dish::getCalories))</code> 统计信息（个数，和，平均值，最大值，最小值）</p>
</li>
<li><p>joining：<code>collect(Collectors.joining(&quot;, &quot;))</code> 对字符串进行拼接</p>
</li>
<li><p>reducing:<code>collect(Collectors.reducing(0, Dish::getCalories, (a, b) -&gt; a + b))</code></p>
</li>
<li><p>groupingBy：<code>collect(Collectors.groupingBy(Dish::getType))</code></p>
<ol>
<li><p>多级分组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">collect(Collectors.groupingBy(Dish::getType, Collectors.groupingBy(dish -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> calories = dish.getCalories();</span><br><span class="line">    <span class="keyword">return</span> getLevel(calories);</span><br><span class="line">&#125;)));</span><br></pre></td></tr></table></figure>
</li>
<li><p>按照分组收集数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">collect(Collectors.groupingBy(</span><br><span class="line">                        Dish::getType, </span><br><span class="line">                        Collectors.maxBy(Comparator.comparingInt(Dish::getCalories))</span><br><span class="line">));</span><br></pre></td></tr></table></figure>
</li>
<li><p>将分组结果进一步转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">collect(Collectors.groupingBy(Dish::getType,</span><br><span class="line">                        Collectors.collectingAndThen(</span><br><span class="line">                        	Collectors.maxBy(</span><br><span class="line">                            	Comparator.comparingInt(Dish::getCalories)</span><br><span class="line">                        	),</span><br><span class="line">                            Optional::get</span><br><span class="line">                        )</span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">collect(Collectors.groupingBy(Dish::getType,</span><br><span class="line">                        Collectors.mapping(</span><br><span class="line">                            dish -&gt; getLevel(dish.getCalories()), Collectors.toSet())</span><br><span class="line">));</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>partitioningBy：<code>collect(Collectors.partitioningBy(Dish::isVegetarian))</code></p>
<ol>
<li>先分区在分组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">collect(Collectors.partitioningBy(</span><br><span class="line">                        Dish::isVegetarian, </span><br><span class="line">                        Collectors.groupingBy(Dish::getType)</span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以将分区看成分组的一个特殊情况</p>
</blockquote>
</li>
</ol>
<p><strong>自定义collector</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * 	Collector&lt;T, A, R&gt; : T流中元素的类型，A局部聚合类型，R最终返回类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeNumbersCollector</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">Integer</span>, <span class="title">Map</span>&lt;<span class="title">Boolean</span>, <span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt;,<span class="title">Map</span>&lt;<span class="title">Boolean</span>, <span class="title">List</span>&lt;<span class="title">Integer</span>&gt;&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 集合操作的起始点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt; supplier() &#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; <span class="keyword">new</span> HashMap&lt;Boolean, List&lt;Integer&gt;&gt;()&#123;&#123;</span><br><span class="line">            put(<span class="keyword">true</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            put(<span class="keyword">false</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 累积遍历过的项目，如何收集流中的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BiConsumer&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;, Integer&gt; accumulator() &#123;</span><br><span class="line">        <span class="keyword">return</span> (Map&lt;Boolean, List&lt;Integer&gt;&gt; acc, Integer candidate) -&gt; &#123;</span><br><span class="line">            acc.get(isPrime(acc.get(<span class="keyword">true</span>), candidate)).add(candidate);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Boolean <span class="title">isPrime</span><span class="params">(List&lt;Integer&gt; primes, Integer candidate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> candidateRoot = (<span class="keyword">int</span>) Math.sqrt(((<span class="keyword">double</span>) candidate));</span><br><span class="line">        <span class="keyword">return</span> takeWhile(primes, i -&gt; i &lt;= candidateRoot)</span><br><span class="line">                .stream()</span><br><span class="line">                .noneMatch(p -&gt; candidate % p == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;A&gt; <span class="function">List&lt;A&gt; <span class="title">takeWhile</span><span class="params">(List&lt;A&gt; list, Predicate&lt;A&gt; predicate)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (A a : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!predicate.test(a))&#123;</span><br><span class="line">                <span class="keyword">return</span> list.subList(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 小合并</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BinaryOperator&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt; combiner() &#123;</span><br><span class="line">        <span class="keyword">return</span> (Map&lt;Boolean, List&lt;Integer&gt;&gt; m1, Map&lt;Boolean, List&lt;Integer&gt;&gt; m2) -&gt; &#123;</span><br><span class="line">            m1.get(<span class="keyword">true</span>).addAll(m2.get(<span class="keyword">true</span>));</span><br><span class="line">            m1.get(<span class="keyword">false</span>).addAll(m2.get(<span class="keyword">false</span>));</span><br><span class="line">            <span class="keyword">return</span> m1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在遍历完流后，finisher必须返回在累计过程的最后要调用的一个函数，以便将累加器对象转换为整个集合操作的结果。</span></span><br><span class="line"><span class="comment">     * 如果累加器的对象恰好符合预期结果，不需要再进行转换，那么直接返回Function.identity()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Function&lt;Map&lt;Boolean, List&lt;Integer&gt;&gt;, Map&lt;Boolean, List&lt;Integer&gt;&gt;&gt; finisher() &#123;</span><br><span class="line">        <span class="comment">// 因为accumulator正好是收集器的结果，所以直接Function.identity()</span></span><br><span class="line">        <span class="keyword">return</span> Function.identity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Characteristics是包含3个结果的枚举。</span></span><br><span class="line"><span class="comment">     * 	UNORDERED：规约的结果不受流中项目的遍历和累计顺序的影响。</span></span><br><span class="line"><span class="comment">     * 	CONCURRENT：accumulator函数可以从多个线程同时调用，且该收集器可以并行归约流。如果收集器没有标为CONCURRENT，那么它仅在用于无序数据源的时候才可以并行归约。</span></span><br><span class="line"><span class="comment">     * IDENTITY_FINISH：这表明finisher方法返回的是一个恒等函数，可以跳过。这种情况下，累加器对象将会直接用作规约过程的的最终结果。这也意味着，将累加器A不经检查的转换为R是安全的。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.IDENTITY_FINISH));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>直接调用<code>parallel()</code>将串行流，转化为并行流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.iterate(<span class="number">1L</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">    .limit(<span class="number">20</span>)</span><br><span class="line">    <span class="comment">// 将顺序流转换为并行流，可以调用sequential()将并行流转换为顺序流</span></span><br><span class="line">    .parallel()</span><br><span class="line">    .reduce(<span class="number">0L</span>, Long::sum);</span><br></pre></td></tr></table></figure>

<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>并行流默认使用<code>ForkJoinPool</code>，其内部的线程数据就是处理器的数量，使用<code>Runtime.getRuntime().availableProcessors()</code>可以获得。</p>
<h5 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h5><p>如果想要使用<code>ForkJoinPool</code>必须创建<code>RecursizeTask</code>，然后实现<code>compute</code>方法，该方法定义了同时定义了将任务拆分成子任务的逻辑，以及无法再拆分或不方便再拆分时，生成单个子任务结果的逻辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(任务足够小或不可拆分)&#123;</span><br><span class="line">    顺序计算该任务</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    将任务分成两个子任务</span><br><span class="line">    递归调用本方法，拆分每个子任务，等待所有子任务完成</span><br><span class="line">    合并每个子任务的结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinSumCalculator</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] numbers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> THRESHOLD = <span class="number">10_000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinSumCalculator</span><span class="params">(<span class="keyword">long</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(numbers, <span class="number">0</span>, numbers.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinSumCalculator</span><span class="params">(<span class="keyword">long</span>[] numbers, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numbers = numbers;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = start - end;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; THRESHOLD)&#123;</span><br><span class="line">            <span class="keyword">return</span> computeSequential();</span><br><span class="line">        &#125;</span><br><span class="line">        ForkJoinSumCalculator leftTask = <span class="keyword">new</span> ForkJoinSumCalculator(numbers, start, start + len / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 开启另一个ForkJoinPool异步执行leftTask</span></span><br><span class="line">        leftTask.fork();</span><br><span class="line">        ForkJoinSumCalculator rightTask = <span class="keyword">new</span> ForkJoinSumCalculator(numbers, start + len / <span class="number">2</span>, end);</span><br><span class="line">        <span class="comment">// 计算rightTask</span></span><br><span class="line">        Long rightResult = rightTask.compute();</span><br><span class="line">        <span class="comment">// 获取leftTask的计算结果，如果没有运行完，则等待</span></span><br><span class="line">        Long leftResult = leftTask.join();</span><br><span class="line">        <span class="keyword">return</span> rightResult + leftResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">computeSequential</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            sum += numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkJoinSumCalculator(numbers);</span><br><span class="line"><span class="keyword">new</span> ForkJoinPool().invoke(task);</span><br></pre></td></tr></table></figure>

<p>工作窃取</p>
<p>问题：由于划分策略效率低或者磁盘访问出现了问题等原因，导致每个子任务所花的时间是不相同的。</p>
<p>解决：</p>
<p>​    每个子线程都为分配给它的任务保存一个双向链式队列，每完成一个任务，就会从队列头上取出下一个任务开始执行。如果某个线程早早完成了分配给它的所有任务，也就是它队列已经空了，而其他的线程还很忙。这时，这个线程并没有闲下来，而是随机选了一个别的线程，从队列的尾巴上“偷走”一个任务。这个过程一直继续下去，直到所有的任务都执行完毕，所有的队列都清空。</p>
<blockquote>
<p>使用并行化的前提：保证在内核中并行执行工作的时间 &gt; 在内核之间数据传递的时间</p>
</blockquote>
<p><strong>注意</strong>：</p>
<ol>
<li>对一个任务调用join会阻塞调用方，直到该任务做出结果</li>
<li>不要在RecursiveTask的内部使用ForkJoinPool的invoke方法</li>
<li>对子任务调用fork方法，会见它排进ForkJoinPool</li>
<li>调试比较麻烦</li>
<li>不要认为在多核处理器上使用Fork/Join就比顺序执行的快<ol>
<li>Fork/Join程序跑几遍才能被JIT优化，所以在测试程序性能的时候先运行几遍很重要。</li>
</ol>
</li>
</ol>
<h4 id="Spliterator"><a href="#Spliterator" class="headerlink" title="Spliterator"></a>Spliterator</h4><p>专门为并行流设计的，用于遍历并行流中的元素。</p>
<p>并行流在使用的时候，Spliterator递归的调用trySplit()，将一个Spliterator拆分为二个，二个拆分为四个，直到处理的数据结构不能拆分为止，此时会返回null</p>
<p><strong>demo</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCounterSpliterator</span> <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">Character</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentChar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WordCounterSpliterator</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Character&gt; action)</span> </span>&#123;</span><br><span class="line">        action.accept(s.charAt(currentChar++));</span><br><span class="line">        <span class="keyword">return</span> currentChar &lt; s.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spliterator&lt;Character&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> remainSize = s.length() - currentChar;</span><br><span class="line">        <span class="keyword">if</span> (remainSize &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> splitPos = currentChar + s.length() / <span class="number">2</span>; splitPos &lt; s.length() ; splitPos++) &#123;</span><br><span class="line">            <span class="comment">// 如果为空格，则表示单词结束，进行拆分</span></span><br><span class="line">            <span class="keyword">if</span> (Character.isWhitespace(s.charAt(splitPos)))&#123;</span><br><span class="line">                Spliterator&lt;Character&gt; spliterator = <span class="keyword">new</span> WordCounterSpliterator(s.substring(currentChar, splitPos));</span><br><span class="line">                currentChar = splitPos;</span><br><span class="line">                <span class="keyword">return</span> spliterator;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.length() - currentChar;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ORDERED + SIZED + SUBSIZED + NONNULL + IMMUTABLE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WordCounterSpliterator spliterator = <span class="keyword">new</span> WordCounterSpliterator(SENTENCE);</span><br><span class="line">Stream&lt;Character&gt; characterStream = StreamSupport.stream(spliterator, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<h4 id="高效使用"><a href="#高效使用" class="headerlink" title="高效使用"></a>高效使用</h4><ol>
<li>如果有疑问，测量</li>
<li>留意装箱</li>
<li>有些操作本身并行流的性能就比顺序流差<ol>
<li>limit</li>
<li>findFirst</li>
</ol>
</li>
<li>考虑流的操作流水线的总计算成本</li>
<li>当个成本越大，使用并行流越好</li>
<li>对于小的数据量，使用并行流从来都不是一个好的选项</li>
<li>考虑流背后的数据结构是否易于拆分<ol>
<li>ArrayList比LinkedList易于拆分，不用遍历</li>
<li>range工厂方法创建的原始类型流也可以快速拆分</li>
</ol>
</li>
<li>流自身的特点，以及流水线中的中间操作修改流的方式，都可能会改变分解过程的性能</li>
<li>终端操作中合并操作的代价是大是小</li>
</ol>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol>
<li>思考方式变成把这样的流变成那样的流，而不是一次只处理一个项目，进行了更高维的抽象。</li>
<li>可以透明地把输入的不相关部分拿到几个CPU内核上去分别执行Stream操作流水线–<strong>这几乎是免费的并行，用不着去费劲搞Thread了</strong></li>
</ol>
<blockquote>
<p><code>Collection</code>主要是为了<strong>存储和访问数据</strong>，而<code>Stream</code>则主要用于<strong>描述对数据得计算</strong></p>
</blockquote>
<h2 id="collection-和-stream"><a href="#collection-和-stream" class="headerlink" title="collection 和 stream"></a>collection 和 stream</h2><ol>
<li>何时计算<ol>
<li>collection中的每个元素都得<strong>先算出来</strong>才能添加到集合中</li>
<li>stream就像是一个延迟创建的集合：<strong>只有在消费者要求的时候才会计算值</strong></li>
</ol>
</li>
<li>迭代<ol>
<li>collection外部迭代：for-each</li>
<li>stream内部迭代：它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出一个函数说要干什么就可以了。</li>
</ol>
</li>
<li>侧重点<ol>
<li>collection主要是为了存储和访问数据</li>
<li>stream主要用于描述对数据的计算</li>
</ol>
</li>
</ol>
<h1 id="Lambda-———-匿名函数"><a href="#Lambda-———-匿名函数" class="headerlink" title="Lambda ——— 匿名函数"></a>Lambda ——— 匿名函数</h1><p>在Java8中，可以使用Lambda表达式，<code>(String s) -&gt; s.length()</code></p>
<ul>
<li><p>函数式接口</p>
<ul>
<li><p>常用的函数式接口</p>
<ul>
<li>Predicate</li>
<li>Consumer</li>
<li>Function</li>
</ul>
<blockquote>
<p>注意：任何函数式接口都不允许抛出受检异常</p>
<ol>
<li>定义一个自己的函数式接口，并声明受检异常</li>
<li>把Lambda包在try/catch中</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p>类型检查的过程:</p>
<ul>
<li>找出filter方法的声明</li>
<li>要求它是Predicate<apple>(目标类型)对象的第二个正式参数</apple></li>
<li>Predicate<apple>是一个函数式接口，定义了一个叫做test的抽象方法</apple></li>
<li>test方法描述了一个函数描述符，它可以接受一个Apple，并返回一个boolean。</li>
<li>filter的任何实际参数都必须匹配这个要求</li>
</ul>
</li>
</ul>
<p>还有方法引用的语法糖，形如<code>File[] hiddenFiles = new File(&quot;.&quot;).listFiles(File::isHidden)</code>。</p>
<blockquote>
<p>在Lambda不能访问共享的可变数据。</p>
</blockquote>
<blockquote>
<p>虽然可以使用synchronized来访问，但是这样会导致系统的优化失去了意义，在多个处理器内核之间使用synchronized，其代价往往比你预期的要大得多，因为同步迫使代码按照顺序执行，而这与并行处理得宗旨相悖。</p>
</blockquote>
<h1 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h1><ol>
<li><p>增加了default方法和static方法, 这两种方法完全可以有方法体</p>
<ol>
<li>default方法属于实例, static方法属于接口</li>
<li>接口里面的static方法不会被继承, 静态变量会被继承下去</li>
</ol>
</li>
<li><p>如果一个类实现了多个接口, 并且这些接口互相之间没有继承关系, 同时存在相同的默认方法,</p>
<p>会报错: 不相关默认值</p>
<ol>
<li>如果多个接口有继承关系, 默认方法会被子接口覆盖</li>
</ol>
</li>
<li><p>如果遇到有多个继承, 并且有相同的默认方法, 实现类可以通过特殊语法指定要访问哪个接口的方法.</p>
<p>在实现类或者子接口中重写默认方法, 在方法里面写:</p>
<p><code>接口.super.方法名(参数);</code></p>
</li>
<li><p>如果一个接口只有一个抽象方法(包括继承的), 该接口是一个函数式接口，函数式接口可以使用lambda表达式实现</p>
</li>
<li><p>如果接口里面使用<code>@FunctionalInterface</code> 注解限定接口里面只能有一个抽象方法</p>
</li>
</ol>
<h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p>使用Optional取代null</p>
<h2 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明null的</span></span><br><span class="line">Optional&lt;Car&gt; optCar = Optional.empty()；</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非空值创建</span></span><br><span class="line">Optional&lt;Car&gt; optCar = Optional.of(car);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可接受null</span></span><br><span class="line">Optional&lt;Car&gt; optCar = Optional.ofNullable(car);</span><br></pre></td></tr></table></figure>

<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>empty</td>
<td>返回一个空的Optional实例</td>
</tr>
<tr>
<td>filter</td>
<td>满足，返回包含值的Optional，否则返回空的Optional对象</td>
</tr>
<tr>
<td>flatMap</td>
<td>值存在，对该值执行提供的mapping函数，返回一个Optional类型的值，否则返回空的Optional对象</td>
</tr>
<tr>
<td>map</td>
<td>值存在，对该值执行提供的mapping函数</td>
</tr>
<tr>
<td>get</td>
<td>值存在，将该值用Optional封装返回，否则抛出NoSuchElementException异常</td>
</tr>
<tr>
<td>ifPresent</td>
<td>值存在，执行使用该值的方法调用，否则什么也不做</td>
</tr>
<tr>
<td>isPresent</td>
<td>值存在，返回true；否则false</td>
</tr>
<tr>
<td>of</td>
<td>将指定值用Optional封装之后返回，如果值为null，抛出NoSuchElementException</td>
</tr>
<tr>
<td>ofNullable</td>
<td>将指定值用Optional封装之后返回，如果值为null，否则返回空的Optional对象</td>
</tr>
<tr>
<td>orElse</td>
<td>有值，返回；否则返回一个默认值</td>
</tr>
<tr>
<td>orElseGet</td>
<td>有值，返回；否则返回一个由制定Supplier接口生成的值</td>
</tr>
<tr>
<td>orElseThrow</td>
<td>有值，返回；否则返回一个由制定Supplier接口生成的异常</td>
</tr>
</tbody></table>
<h1 id="CompletableFuture：组合异步编程"><a href="#CompletableFuture：组合异步编程" class="headerlink" title="CompletableFuture：组合异步编程"></a>CompletableFuture：组合异步编程</h1><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>Future是对将来某个时刻会发生的结果进行建模，它建模了一种异步运算，返回一个执行运算结果的引用，当运算结束后，这个引用被返回给调用方。在Future中触发哪些潜在耗时的操作把调用线程解放出来，让它能继续执行其他有价值的工作，不再需要呆呆等待耗时的操作完成。</p>
<p>相对于Thread，其更易使用，通常你只需要将耗时的操作封装在一个Callable对象中，再将它提交给ExecutorService，就OK了。</p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">Future&lt;Double&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 可以异步的做其他的事情</span></span><br><span class="line"><span class="comment">// do something else</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// get() : 获取计算结果，如果没有计算完成，则阻塞当前的线程，直到计算完成</span></span><br><span class="line">    <span class="comment">// 可以设置超时时间，避免永久等待</span></span><br><span class="line">    Double result = future.get(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><p>我们很难表述Futrue结果之间的依赖性</p>
<ol>
<li>将两个异步计算合并为一个——这两个异步计算之间相互独立，同时第二个又依赖于第一个的结果</li>
<li>等待Future集合中所有任务都完成</li>
<li>仅等待Future集合中最快结束的任务完成，并返回它的结果</li>
<li>….</li>
</ol>
<h2 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h2><p>CompletableFuture对Future进行了封装，更简单的使用Future</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shop</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    public Future&lt;Double&gt; getPriceAsync(String product)&#123;</span></span><br><span class="line"><span class="comment">//        CompletableFuture&lt;Double&gt; futurePrice = new CompletableFuture&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        new Thread(() -&gt; &#123;</span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                double price = calculatePrice(product);</span></span><br><span class="line"><span class="comment">//                futurePrice.complete(price);</span></span><br><span class="line"><span class="comment">//            &#125; catch (Exception e)&#123;</span></span><br><span class="line"><span class="comment">//                // 避免调用线程永久阻塞，抛出异常</span></span><br><span class="line"><span class="comment">//                throw new CompletionException(e);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;).start();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        return futurePrice;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等价于上面</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">getPriceAsync</span><span class="params">(String product)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; calculatePrice(product));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">(String product)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calculatePrice(product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">calculatePrice</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> random.nextDouble() * product.charAt(<span class="number">0</span>) + product.charAt(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">executor = Executors.newFixedThreadPool(Math.min(shops.size(), <span class="number">100</span>), r -&gt; &#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">    <span class="comment">// 设置守护线程 ---- 这种方式不会阻止线程的关停</span></span><br><span class="line">    thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;);</span><br><span class="line">List&lt;String&gt; prices = findPricesDiscount(<span class="string">"computer"</span>, shops, executor);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">findPricesDiscount</span><span class="params">(String product, List&lt;Shop&gt; shops, Executor executor)</span></span>&#123;</span><br><span class="line">    List&lt;CompletableFuture&lt;String&gt;&gt; futures = shops.stream()</span><br><span class="line">        .map(shop -&gt; CompletableFuture.supplyAsync(</span><br><span class="line">            () -&gt; shop.getName() +<span class="string">":"</span>+ shop.getPrice(product) + <span class="string">""</span>,</span><br><span class="line">            executor))</span><br><span class="line">        .map(future -&gt; future.thenApply(Quote::parse))</span><br><span class="line">        <span class="comment">// thenCompose：第二个Future使用第一个Future的计算结果</span></span><br><span class="line">        <span class="comment">// thenCombine：两个Future并行执行，结果合并。没有依赖关系</span></span><br><span class="line">        <span class="comment">// thenAccept：参数定义了对Future的计算结果执行什么，如果Future返回了计算结果就返回CompletableFuture&lt;Void&gt;</span></span><br><span class="line">        .map(future -&gt; future.thenCompose(quote -&gt;</span><br><span class="line">                                          CompletableFuture.supplyAsync(</span><br><span class="line">                                              () -&gt;Discount.applyDiscount(quote),</span><br><span class="line">                                              executor)))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 考虑到流的延迟特性，如果在单一流水线中处理流，发向不同商家的请求只能以同步，顺序的执行方式才会成功</span></span><br><span class="line">        <span class="comment">// 所以拆分成两个流</span></span><br><span class="line">        <span class="keyword">return</span> futures.stream()</span><br><span class="line">            <span class="comment">// join：完成返回结果，完成出现异常，则抛出异常</span></span><br><span class="line">            .map(CompletableFuture::join)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果是一个流，由于是pipeline的处理模式，所以当执行到map(CompletableFuture::join)会等待，然后再执行第二次，future是一个个创建的，一个个执行的；</p>
<p>如果拆分成两个流，那么future创建的过程是并行的，那么启动线程执行时也是并行的，所以是并行的计算。</p>
</blockquote>
<blockquote>
<p>anyOf：其中一个Future执行完成就不等待<br><code>CompletableFuture.allOf(futures).join();</code></p>
</blockquote>
<h1 id="新的时间和日期"><a href="#新的时间和日期" class="headerlink" title="新的时间和日期"></a>新的时间和日期</h1><h2 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h2><p>日期类，只显示日期，不显示时间信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">17</span>);</span><br><span class="line"><span class="keyword">int</span> year = date.getYear();</span><br><span class="line">Month month = date.getMonth();</span><br><span class="line"><span class="keyword">int</span> day = date.getDayOfMonth();</span><br><span class="line">DayOfWeek week = date.getDayOfWeek();</span><br><span class="line"><span class="keyword">int</span> length = date.lengthOfMonth();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否闰年</span></span><br><span class="line"><span class="keyword">boolean</span> isLeapYear = date.isLeapYear();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 获取当前日期</span></span><br><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过ChronoField访问日期信息</span></span><br><span class="line"><span class="keyword">int</span> yearNow = now.get(ChronoField.YEAR);</span><br></pre></td></tr></table></figure>

<h2 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h2><p>时间类，只显示时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalTime time = LocalTime.of(<span class="number">13</span>, <span class="number">45</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">int</span> hour = time.getHour();</span><br><span class="line"><span class="keyword">int</span> minute = time.getMinute();</span><br><span class="line"><span class="keyword">int</span> second = time.getSecond();</span><br></pre></td></tr></table></figure>

<h2 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h2><p>日期+时间，不带时区信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime dt1 = LocalDateTime.of(date, time);</span><br><span class="line"><span class="comment">// 2019-10-12T09:28:35</span></span><br><span class="line">LocalDateTime dt2 = LocalDateTime.of(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">28</span>, <span class="number">35</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// LocalDate + LocalTime</span></span><br><span class="line">LocalDateTime dt3 = date.atTime(time);</span><br><span class="line"><span class="comment">// LocalTime + LocalDate</span></span><br><span class="line">LocalDateTime dt4 = time.atDate(date);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取LocalTime</span></span><br><span class="line">LocalTime time = dt1.toLocalTime();</span><br><span class="line"><span class="comment">// 获取LocalDate</span></span><br><span class="line">LocalDate date = dt1.toLocalDate();</span><br></pre></td></tr></table></figure>

<h2 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h2><p>时间戳类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Instant it1 = Instant.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间戳，单位s</span></span><br><span class="line"><span class="keyword">long</span> timestamp = instant.getLong(ChronoField.INSTANT_SECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对于计算机元年偏移时间</span></span><br><span class="line">Instant it2 = Instant.ofEpochSecond(<span class="number">1</span>, <span class="number">1_000_000_000</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Duration-和-Period"><a href="#Duration-和-Period" class="headerlink" title="Duration 和 Period"></a>Duration 和 Period</h2><p>用来比较<code>LocalTime</code>，<code>LocalDateTime</code>，<code>Instant</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Duration duration = Duration.between(t1, t2);</span><br><span class="line"><span class="keyword">long</span> seconds = duration.getSeconds();</span><br></pre></td></tr></table></figure>

<h2 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h2><p>用来比较<code>LocalDate</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Period period = Period.between(d1, d1);</span><br><span class="line"><span class="keyword">int</span> days = period.getDays();</span><br></pre></td></tr></table></figure>

<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>调用<code>parse</code>方法，来改变日期的格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BASIC_ISO_DATE - 20190517</span></span><br><span class="line"><span class="comment">// ISO_LOCAL_DATE - 2018-05-17</span></span><br><span class="line">LocalDate date6 = LocalDate.parse(<span class="string">"20190517"</span>, DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置解析格式，设置某个地区</span></span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">""</span>, Locale.CHINA);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义formatter</span></span><br><span class="line">DateTimeFormatter dateTimeFormatter = <span class="keyword">new</span> DateTimeFormatterBuilder()</span><br><span class="line">    .appendText(ChronoField.YEAR)</span><br><span class="line">    .appendInstant()</span><br><span class="line">    .toFormatter(Locale.CHINA);</span><br></pre></td></tr></table></figure>

<h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><p>ZoneId，时区的ID，基于TZDB获取</p>
<p>ZoneDateTime，= LocalDate + LocalTime + ZoneId</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取zoneId</span></span><br><span class="line">ZoneId zoneId = ZoneId.of(<span class="string">"Europe/Rome"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将TimeZone转为ZoneId</span></span><br><span class="line">ZoneId zoneId1 = TimeZone.getDefault().toZoneId();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加时区</span></span><br><span class="line">ZonedDateTime zonedDateTime = date.atStartOfDay(zoneId);</span><br></pre></td></tr></table></figure>

<h2 id="其他的日历系统"><a href="#其他的日历系统" class="headerlink" title="其他的日历系统"></a>其他的日历系统</h2><p>支持的日历系统</p>
<p>ThaiBuddhistDate：泰国佛教</p>
<p>MinguoDate：民国</p>
<p>JapaneseDate：日本</p>
<p>HijrahDate：伊斯兰教</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转化为相应的日历系统</span></span><br><span class="line">MinguoDate mgd = MinguoDate.from(d1);</span><br></pre></td></tr></table></figure>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">ZEP</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://zepc.github.io/2019/06/02/Java8实战/">http://zepc.github.io/2019/06/02/Java8实战/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/读书笔记/">读书笔记</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/04/21/SQL基础教程/"><i class="fa fa-chevron-left">  </i><span>《SQL基础教程》</span></a></div><div class="next-post pull-right"><a href="/2019/06/02/hive编程指南/"><span>《Hive编程指南》</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(/img/top_background/jobs.png)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2021 By ZEP</div><div class="footer_custom_text">Hi, Welcome to my <a href="https://frog1024.github.io">blog</a>!</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>